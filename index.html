<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="styles/css/main.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiSSiKk - home</title>
    <!-- Prevent white flash before CSS/JS applies the background -->
    <style>
        html, body { background: #000; }
    </style>
</head>
<body>

<div id="bg-layer-a" class="bg-layer is-visible"></div>
<div id="bg-layer-b" class="bg-layer"></div>

<div class="content-wrapper">
    <h1>LiSSiKk</h1>
    <p><b>L</b>ogic <b>I</b>ntegral <b>S</b>atisfaction <b>S</b>pirit <b>I</b>ntelligence <b>K</b>een <b>k</b>nowledge
    </p>
</div>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').catch(() => {});
        });
    }

    const IMAGE_NUMBER_MIN = 1;
    const IMAGE_NUMBER_MAX = 42;
    const IMAGE_NUMBER_PAD = 2;

    const DEFAULT_IMAGE_EXT = 'jpg';
    const IMAGE_EXT_BY_NUMBER = {
        4: 'png',
    };

    const RECENT_IMAGES_LIMIT = 10;

    function buildImageUrl(num) {
        const nn = String(num).padStart(IMAGE_NUMBER_PAD, '0');
        const ext = IMAGE_EXT_BY_NUMBER[num] || DEFAULT_IMAGE_EXT;
        return `static/img${nn}.${ext}`;
    }

    const imageUrls = Array.from(
        {length: IMAGE_NUMBER_MAX - IMAGE_NUMBER_MIN + 1},
        (_, i) => buildImageUrl(IMAGE_NUMBER_MIN + i)
    );

    let currentImageUrl = null;
    let currentImageSize = null;
    let currentImageEl = null;

    const bgLayerA = document.getElementById('bg-layer-a');
    const bgLayerB = document.getElementById('bg-layer-b');
    let bgVisibleLayer = bgLayerA;
    let bgHiddenLayer = bgLayerB;
    let bgRenderedKey = null; // `${tileMode}|${bgUrl}`

    const tileUrlCache = new Map();
    const recentImageUrls = [];
    const badImageUrls = new Set();

    const STORAGE_KEYS = {
        recent: 'lissikk:recentImageUrls:v1',
        last: 'lissikk:lastImageUrl:v1',
        lastMeta: 'lissikk:lastImageMeta:v1', // { url, width, height }
    };

    function safeStorageGet(key) {
        try {
            return window.localStorage.getItem(key);
        } catch {
            return null;
        }
    }

    function safeJsonParse(raw) {
        if (!raw) return null;
        try {
            return JSON.parse(raw);
        } catch {
            return null;
        }
    }

    function persistLastMeta(url, size) {
        if (!url || !size) return;
        if (typeof size.width !== 'number' || typeof size.height !== 'number') return;
        safeStorageSet(STORAGE_KEYS.lastMeta, JSON.stringify({url, width: size.width, height: size.height}));
    }

    function setBackgroundStyles(targetEl, bgUrl, tileMode) {
        // No dark overlay here; blur/fade is handled by CSS on .bg-layer.
        targetEl.style.backgroundImage = `url('${bgUrl}')`;
        targetEl.style.backgroundAttachment = 'fixed';

        if (tileMode === 'x') {
            targetEl.style.backgroundSize = 'auto 100%';
            targetEl.style.backgroundRepeat = 'repeat-x';
            targetEl.style.backgroundPosition = 'center center';
            return;
        }
        if (tileMode === 'y') {
            targetEl.style.backgroundSize = '100% auto';
            targetEl.style.backgroundRepeat = 'repeat-y';
            targetEl.style.backgroundPosition = 'center center';
            return;
        }

        targetEl.style.backgroundSize = 'cover';
        targetEl.style.backgroundRepeat = 'no-repeat';
        targetEl.style.backgroundPosition = 'center center';
    }

    function computeTileMode(imageSize) {
        if (!imageSize || typeof imageSize.width !== 'number' || typeof imageSize.height !== 'number') return null;
        const isPortraitImage = imageSize.height > imageSize.width;
        const viewportLandscape = isViewportLandscape();
        const tileByX = viewportLandscape && isPortraitImage;
        const tileByY = !viewportLandscape && !isPortraitImage;
        if (tileByX) return 'x';
        if (tileByY) return 'y';
        return null;
    }

    function tileServiceAvailable() {
        // Works only when SW is actually controlling the page (usually after first reload).
        return !!(navigator.serviceWorker && navigator.serviceWorker.controller);
    }

    function tileServiceUrl(src, axis) {
        return `__tile?src=${encodeURIComponent(src)}&axis=${encodeURIComponent(axis)}`;
    }

    function crossfadeTo(bgUrl, tileMode, {sharp = true} = {}) {
        if (!bgVisibleLayer || !bgHiddenLayer) return false;

        setBackgroundStyles(bgHiddenLayer, bgUrl, tileMode);
        setLayerSharp(bgHiddenLayer, !!sharp);
        bgHiddenLayer.classList.add('is-visible');

        // next frame: swap opacity classes (prevents any intermediate blank)
        requestAnimationFrame(() => {
            bgVisibleLayer.classList.remove('is-visible');
            const tmp = bgVisibleLayer;
            bgVisibleLayer = bgHiddenLayer;
            bgHiddenLayer = tmp;
        });

        return true;
    }

    function makeBgKey(bgUrl, tileMode) {
        return `${tileMode || ''}|${bgUrl}`;
    }

    function renderBackgroundImmediate(bgUrl, tileMode) {
        // Default: immediate render but keep current layer's "sharp" state untouched.
        // (We explicitly set sharpness below.)
        return renderBackgroundImmediateWithOptions(bgUrl, tileMode, {sharp: true});
    }

    function setLayerSharp(el, sharp) {
        if (!el) return;
        if (sharp) el.classList.add('is-sharp');
        else el.classList.remove('is-sharp');
    }

    function renderBackgroundImmediateWithOptions(bgUrl, tileMode, {sharp}) {
        const key = makeBgKey(bgUrl, tileMode);
        if (key === bgRenderedKey) return;

        const target = bgVisibleLayer || document.body;
        setBackgroundStyles(target, bgUrl, tileMode);
        if (bgVisibleLayer) bgVisibleLayer.classList.add('is-visible');
        if (bgVisibleLayer) setLayerSharp(bgVisibleLayer, !!sharp);
        bgRenderedKey = key;
    }

    function renderBackgroundCrossfade(bgUrl, tileMode) {
        return renderBackgroundCrossfadeWithOptions(bgUrl, tileMode, {sharp: true});
    }

    function renderBackgroundCrossfadeWithOptions(bgUrl, tileMode, {sharp}) {
        const key = makeBgKey(bgUrl, tileMode);
        if (key === bgRenderedKey) return;

        if (!crossfadeTo(bgUrl, tileMode, {sharp})) {
            renderBackgroundImmediateWithOptions(bgUrl, tileMode, {sharp});
            return;
        }
        bgRenderedKey = key;
    }

    function applyQuickBackground(imageUrl, imageSize) {
        const tileMode = computeTileMode(imageSize);
        // "Stub" background:
        // - keep it blurred
        // - but if SW tile endpoint is available, use the same mirrored/seamless tile as the final render
        const url = (tileMode && tileServiceAvailable()) ? tileServiceUrl(imageUrl, tileMode) : imageUrl;
        renderBackgroundImmediateWithOptions(url, tileMode, {sharp: false});
    }

    function applyInitialBackgroundFromStorage() {
        const meta = safeJsonParse(safeStorageGet(STORAGE_KEYS.lastMeta));
        const metaUrl = meta && typeof meta.url === 'string' ? meta.url : null;
        const metaW = meta && typeof meta.width === 'number' ? meta.width : null;
        const metaH = meta && typeof meta.height === 'number' ? meta.height : null;
        const metaSize = (metaW && metaH) ? {width: metaW, height: metaH} : null;

        const lastFromStorage = safeStorageGet(STORAGE_KEYS.last);
        const url = (metaUrl && imageUrls.includes(metaUrl))
            ? metaUrl
            : (lastFromStorage && imageUrls.includes(lastFromStorage) ? lastFromStorage : null);

        if (!url) return;

        applyQuickBackground(url, metaUrl === url ? metaSize : null);
        currentImageUrl = url;
        if (metaUrl === url && metaSize) currentImageSize = metaSize;

        // Upgrade to seamless tiling in background (won't override if a new image got chosen).
        window.setTimeout(() => void (async () => {
            try {
                const img = await loadImage(url);
                const size = {width: img.naturalWidth, height: img.naturalHeight};
                if (currentImageUrl !== url) return;
                currentImageEl = img;
                currentImageSize = size;
                persistLastMeta(url, size);
                const {bgUrl, tileMode} = await computeBgUrl(url, size, img);
                // If seamless URL differs (blob), crossfade it in; if identical, do nothing (prevents "re-apply" flash).
                renderBackgroundCrossfadeWithOptions(bgUrl, tileMode, {sharp: true});
            } catch {
            }
        })(), 250);
    }

    function safeStorageSet(key, value) {
        try {
            window.localStorage.setItem(key, value);
            return true;
        } catch {
            return false;
        }
    }

    function loadStateFromStorage() {
        const recentRaw = safeStorageGet(STORAGE_KEYS.recent);
        if (recentRaw) {
            try {
                const parsed = JSON.parse(recentRaw);
                if (Array.isArray(parsed)) {
                    const filtered = parsed.filter((u) => typeof u === 'string' && imageUrls.includes(u));
                    recentImageUrls.splice(0, recentImageUrls.length, ...filtered.slice(0, RECENT_IMAGES_LIMIT));
                }
            } catch {
            }
        }
    }

    function persistStateToStorage() {
        safeStorageSet(STORAGE_KEYS.recent, JSON.stringify(recentImageUrls.slice(0, RECENT_IMAGES_LIMIT)));
        safeStorageSet(STORAGE_KEYS.last, recentImageUrls[0] || '');
        if (recentImageUrls[0] && currentImageUrl === recentImageUrls[0] && currentImageSize) {
            persistLastMeta(currentImageUrl, currentImageSize);
        }
    }

    function rememberRecent(url) {
        const idx = recentImageUrls.indexOf(url);
        if (idx !== -1) recentImageUrls.splice(idx, 1);
        recentImageUrls.unshift(url);
        if (recentImageUrls.length > RECENT_IMAGES_LIMIT) recentImageUrls.length = RECENT_IMAGES_LIMIT;
        persistStateToStorage();
    }

    function chooseNextImageUrl() {
        const available = imageUrls.filter((u) => !badImageUrls.has(u));
        if (!available.length) return null;

        const lastFromStorage = safeStorageGet(STORAGE_KEYS.last);
        const lastShown = (recentImageUrls[0] || lastFromStorage || null);
        const avoid = new Set([currentImageUrl, lastShown].filter(Boolean));

        const preferred = available.filter((u) => !avoid.has(u) && !recentImageUrls.includes(u));
        const pool1 = preferred.length ? preferred : available.filter((u) => !avoid.has(u));
        const pool = pool1.length ? pool1 : available;

        return pool[Math.floor(Math.random() * pool.length)];
    }

    function isViewportLandscape() {
        return window.innerWidth >= window.innerHeight;
    }

    function loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = url;
        });
    }

    function canvasToBlobUrl(canvas) {
        return new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
                if (!blob) return reject(new Error('Failed to create blob'));
                resolve(URL.createObjectURL(blob));
            }, 'image/png');
        });
    }

    async function getSeamlessTileUrl(img, axis) {
        const key = `${img.src}|${axis}`;
        const cached = tileUrlCache.get(key);
        if (cached) return cached;

        const w = img.naturalWidth;
        const h = img.naturalHeight;

        const canvas = document.createElement('canvas');
        canvas.width = axis === 'x' || axis === 'xy' ? w * 2 : w;
        canvas.height = axis === 'y' || axis === 'xy' ? h * 2 : h;

        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('No 2D context');

        // (0,0) original
        ctx.drawImage(img, 0, 0, w, h);

        if (axis === 'x') {
            ctx.translate(w * 2, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(img, 0, 0, w, h);
        } else {
            ctx.translate(0, h * 2);
            ctx.scale(1, -1);
            ctx.drawImage(img, 0, 0, w, h);
        }
        ctx.restore();

        const blobUrl = await canvasToBlobUrl(canvas);
        tileUrlCache.set(key, blobUrl);
        return blobUrl;
    }

    async function computeBgUrl(imageUrl, imageSize, imageEl) {
        const tileMode = computeTileMode(imageSize);
        // Prefer SW tile endpoint so placeholder and final rendering match perfectly across reloads.
        if ((tileMode === 'x' || tileMode === 'y') && tileServiceAvailable()) {
            return {bgUrl: tileServiceUrl(imageUrl, tileMode), tileMode};
        }

        // Fallback: client-side canvas tile (no persistence across reloads).
        let bgUrl = imageUrl;
        if ((tileMode === 'x' || tileMode === 'y') && imageEl) {
            bgUrl = await getSeamlessTileUrl(imageEl, tileMode);
        }
        return {bgUrl, tileMode};
    }

    async function applyBackgroundTo(targetEl, imageUrl, imageSize, imageEl) {
        const {bgUrl, tileMode} = await computeBgUrl(imageUrl, imageSize, imageEl);
        setBackgroundStyles(targetEl, bgUrl, tileMode);
        if (targetEl === bgVisibleLayer || (!bgVisibleLayer && targetEl === document.body)) {
            bgRenderedKey = makeBgKey(bgUrl, tileMode);
        }
    }

    async function setRandomBackground() {
        const maxAttempts = Math.min(imageUrls.length, 10);
        let selectedImage = null;
        for (let i = 0; i < maxAttempts; i++) {
            const candidate = chooseNextImageUrl();
            if (!candidate) break;
            if (candidate === selectedImage) continue;
            selectedImage = candidate;
            try {
                currentImageEl = await loadImage(selectedImage);
                currentImageSize = {width: currentImageEl.naturalWidth, height: currentImageEl.naturalHeight};
                currentImageUrl = selectedImage;
                rememberRecent(selectedImage);
                const {bgUrl, tileMode} = await computeBgUrl(selectedImage, currentImageSize, currentImageEl);
                renderBackgroundCrossfadeWithOptions(bgUrl, tileMode, {sharp: true});
                return;
            } catch {
                badImageUrls.add(selectedImage);
            }
        }

        document.body.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5))`;
    }

    let resizeTimer = null;
    window.addEventListener('resize', () => {
        if (!currentImageUrl || !currentImageSize) return;
        window.clearTimeout(resizeTimer);
        resizeTimer = window.setTimeout(() => {
            const target = bgVisibleLayer || document.body;
            void applyBackgroundTo(target, currentImageUrl, currentImageSize, currentImageEl);
        }, 100);
    });

    window.addEventListener('load', () => {
        loadStateFromStorage();
        // Show the last image immediately (usually cached) to avoid a flash on refresh.
        applyInitialBackgroundFromStorage();
        void setRandomBackground();
    });
</script>
</body>
</html>
